---

title: Matplotlib Part 4 — Advanced Concepts (Scales, Ticks, Grids, Colormaps & 3D)
sidebar_label: Matplotlib Part 4 — Advanced Concepts
sidebar_position: 21
--------------------

## Overview

Ready to go from “it runs” to **publication-quality**?
This chapter levels you up on the Matplotlib OO interface with practical, composable techniques:

* Axis **scales** (log, symlog, logit)
* **Ticks**, **locators**, **formatters**, and scientific notation
* Precise **spacing** (labels, margins, layout engines)
* **Grids**, **spines**, and axes at zero
* **Twin/secondary axes** (and when *not* to use them)
* Inset axes, GridSpec, subfigures
* **Colormaps**, **norms**, **images**, **contours**, colorbars
* Lightweight **3D** plotting
* Style sheets, `rcParams`, annotations, saving/export tips

Throughout, jargon is explained inline and reinforced with examples.

---

## 1) Axis scales (log, symlog, logit)

Use non-linear scales to reveal structure across magnitudes.

```python
import numpy as np, matplotlib.pyplot as plt

x = np.logspace(-2, 2, 200)
y = x**2

fig, ax = plt.subplots()
ax.plot(x, y)
ax.set_xscale('log')     # 'linear' | 'log' | 'symlog' | 'logit'
ax.set_yscale('log')
ax.set_xlabel('x (log scale)')
ax.set_ylabel('y (log scale)')
ax.set_title('Log–Log plot')
```

- **`'log'`**: positive values only; zeros/negatives are invalid.
- **`'symlog'`**: symmetric about 0 (good for signed data); add `linthresh`:

  ```python
  ax.set_yscale('symlog', linthresh=1e-2)
  ```

- **`'logit'`**: probabilities (0‒1); beware exact 0/1 → add tiny eps.

**Tip:** Mask or clip invalid values before plotting:

```python
y = np.clip(y, 1e-12, None)
```

---

## 2) Ticks, locators, and formatters (a.k.a. precise tick control)

**Locators** decide _where_ ticks land; **formatters** decide _how_ they look.

```python
import matplotlib.ticker as mticker

fig, ax = plt.subplots()
x = np.linspace(0, 10, 100)
ax.plot(x, np.sin(x))

# Major ticks every 2, minor every 0.5
ax.xaxis.set_major_locator(mticker.MultipleLocator(2))
ax.xaxis.set_minor_locator(mticker.MultipleLocator(0.5))

# Use a custom formatter
ax.yaxis.set_major_formatter(mticker.StrMethodFormatter('{x:.2f}'))

ax.tick_params(axis='both', which='major', length=6, width=1.2)
ax.tick_params(axis='both', which='minor', length=3, color='0.5')
```

**Useful locators**

- `MultipleLocator(step)` — fixed spacing
- `AutoLocator()` / `MaxNLocator()` — auto, with max ticks
- `AutoMinorLocator()` — automatic minor ticks
- `LogLocator(base=10)` — ticks on log scales
- Date/time: `matplotlib.dates.AutoDateLocator()`

**Useful formatters**

- `ScalarFormatter(useMathText=True)` — “nice” decimals, optional sci-notation
- `FuncFormatter(func)` — custom string from value/position
- `StrMethodFormatter('{x:.1f}')` — f-string–style
- Engineering: `EngFormatter(unit='Hz')`
- Date/time: `matplotlib.dates.DateFormatter('%Y-%m')`

---

## 3) Scientific notation & tick label style

Two convenient approaches:

```python
# Approach A: ScalarFormatter with power limits
sf = mticker.ScalarFormatter(useMathText=True)
sf.set_powerlimits((-3, 3))   # outside this → scientific
ax.yaxis.set_major_formatter(sf)

# Approach B: ticklabel_format
ax.ticklabel_format(style='sci', axis='y', scilimits=(-3, 3))
```

**Note:** For large/small data + tiny variation, consider rescaling your data or
adding an **offset** formatter.

---

## 4) Spacing: label pads, margins, tight/constrained layout

```python
fig, ax = plt.subplots()
ax.set_xlabel('Time (s)', labelpad=10)   # distance from axis
ax.set_ylabel('Amplitude', labelpad=10)

# Avoid clipping labels
fig.tight_layout()                        # quick & effective
# or:
fig.set_constrained_layout(True)          # smarter global layout

# When saving:
fig.savefig('out.png', bbox_inches='tight', pad_inches=0.05, dpi=200)
```

- `tight_layout()` works well for many cases.
- `constrained_layout=True` (set on figure creation or via set\_) can handle
  complex nested layouts better.
- `bbox_inches='tight'` trims extra whitespace.

---

## 5) Grid lines (major & minor)

```python
fig, ax = plt.subplots()
ax.plot(x, np.sin(x))
ax.grid(True, which='major', linestyle='--', alpha=0.6)
ax.grid(True, which='minor', linestyle=':', alpha=0.5)
ax.minorticks_on()
```

Pair minor ticks with lighter, dotted grid lines for subtle guidance.

---

## 6) Spines and axes-through-zero

**Spines** are the borders around the plotting area.

```python
fig, ax = plt.subplots()
ax.plot(x, np.sin(x))

# Hide top/right spines (clean look)
for side in ('top', 'right'):
    ax.spines[side].set_visible(False)

# Move axes to cross at (0, 0)
ax.spines['left'].set_position('zero')
ax.spines['bottom'].set_position('zero')
ax.spines['left'].set_linewidth(1.2)
ax.spines['bottom'].set_linewidth(1.2)
ax.yaxis.set_ticks_position('left')
ax.xaxis.set_ticks_position('bottom')
```

---

## 7) Twin axes vs. secondary axes (which to use?)

### `twinx()` / `twiny()` (independent scale)

Good for _different_ units that share the same x (or y).

```python
fig, ax1 = plt.subplots()
ax2 = ax1.twinx()

ax1.plot(x, np.sin(x), color='tab:blue', label='sin')
ax2.plot(x, np.cos(x)*100, color='tab:red', label='cos ×100')

ax1.set_ylabel('sin(x)', color='tab:blue')
ax2.set_ylabel('cos(x) × 100', color='tab:red')
ax1.tick_params(axis='y', colors='tab:blue')
ax2.tick_params(axis='y', colors='tab:red')
```

**Caveat:** Two y-scales can mislead; styling must make it obvious.

### `secondary_yaxis` (linked via a conversion function)

Best when the second axis is a **deterministic transform** of the first.

```python
def celsius_to_fahrenheit(c): return c * 9/5 + 32
def fahrenheit_to_celsius(f): return (f - 32) * 5/9

fig, ax = plt.subplots()
ax.plot(x, x, label='°C')

sec = ax.secondary_yaxis('right', functions=(celsius_to_fahrenheit, fahrenheit_to_celsius))
sec.set_ylabel('°F')
```

---

## 8) Inset axes & GridSpec

### Inset for zoom or detail

```python
from mpl_toolkits.axes_grid1.inset_locator import inset_axes, mark_inset

fig, ax = plt.subplots()
ax.plot(x, np.sin(x))

ins = inset_axes(ax, width="35%", height="35%", loc='upper right', borderpad=1)
ins.plot(x, np.sin(x))
ins.set_xlim(2, 4); ins.set_ylim(0.5, 1)
mark_inset(ax, ins, loc1=2, loc2=4, fc="none", ec="0.5")
```

### GridSpec for complex grids

```python
import matplotlib.gridspec as gridspec
fig = plt.figure(constrained_layout=True)
gs = gridspec.GridSpec(2, 3, figure=fig)
ax_big = fig.add_subplot(gs[:, :2])
ax_small = fig.add_subplot(gs[0, 2])
ax_small2 = fig.add_subplot(gs[1, 2])
```

---

## 9) Colormaps, norms, images, contours & colorbars

### Choosing a colormap

- **Perceptually uniform** (great default): `viridis`, `plasma`, `cividis`
- **Diverging** (centered data/anomalies): `coolwarm`, `seismic`, `RdBu`
- **Sequential** (monotonic data): `magma`, `inferno`, `Greens`

### Normalization (mapping data → colors)

- Linear (default)
- `LogNorm` (decades), `SymLogNorm` (signed, with linear threshold),
  `TwoSlopeNorm` (center at 0), `CenteredNorm`

```python
from matplotlib.colors import LogNorm, TwoSlopeNorm

Z = np.random.lognormal(mean=0, sigma=1, size=(200, 200))

fig, ax = plt.subplots()
im = ax.imshow(Z, norm=LogNorm(), cmap='viridis', origin='lower')
cbar = fig.colorbar(im, ax=ax)
cbar.set_label('Intensity')
```

### Contours

```python
X = np.linspace(-3, 3, 200)
Y = np.linspace(-3, 3, 200)
XX, YY = np.meshgrid(X, Y)
Z = np.sin(XX**2 + YY**2)

fig, ax = plt.subplots()
cs = ax.contourf(XX, YY, Z, levels=20, cmap='coolwarm')
fig.colorbar(cs, ax=ax)
```

### `imshow` vs `pcolor`/`pcolormesh`

- `imshow`: fast image display; use `extent=` to set data coords;
  `origin='lower'` for conventional math plots.
- `pcolormesh`: flexible grid; better when cells represent areas with edges; can
  be slower.

---

## 10) Other handy 2D plot types

```python
# Bar & Barh
ax.bar(['A','B','C'], [5, 3, 7])
ax.barh(['A','B','C'], [5, 3, 7])

# Area / fill_between
ax.fill_between(x, np.sin(x), alpha=0.3)

# Step / Staircase
ax.step(x, np.sin(x), where='mid')

# Error bars
ax.errorbar(x[::5], np.sin(x[::5]), yerr=0.2, fmt='o')
```

---

## 11) Lightweight 3D

```python
from mpl_toolkits.mplot3d import Axes3D  # registers projection
fig = plt.figure(figsize=(7,5))
ax = fig.add_subplot(111, projection='3d')

u = np.linspace(0, 2*np.pi, 50)
v = np.linspace(0, np.pi, 25)
x = 1*np.outer(np.cos(u), np.sin(v))
y = 1*np.outer(np.sin(u), np.sin(v))
z = 1*np.outer(np.ones_like(u), np.cos(v))

ax.plot_surface(x, y, z, cmap='viridis', edgecolor='none')
ax.set_box_aspect([1,1,1])   # equal aspect
```

- 3D is less performant; keep meshes modest.
- Add colorbars for surface values:

  ```python
  m = ax.plot_surface(..., cmap='plasma')
  fig.colorbar(m, ax=ax, shrink=0.7)
  ```

---

## 12) Styles, rcParams, annotations, saving

### Styles & rcParams

```python
plt.style.use('seaborn-v0_8')        # or 'ggplot', 'fivethirtyeight', etc.

import matplotlib as mpl
mpl.rcParams['axes.titlesize'] = 12
mpl.rcParams['axes.labelsize']  = 11
mpl.rcParams['lines.linewidth'] = 2.0
```

Wrap in a context to keep changes local:

```python
with mpl.rc_context({'font.size': 10, 'axes.grid': True}):
    fig, ax = plt.subplots()
    ax.plot(x, np.cos(x))
```

### Annotations

```python
ax.annotate('Local max', xy=(np.pi/2, 1),
            xytext=(2.5, 1.2),
            arrowprops=dict(arrowstyle='->', lw=1.2))
```

### Saving & export

```python
fig.savefig('figure.pdf')                       # vector (great for print)
fig.savefig('figure.png', dpi=300, transparent=True, facecolor='white')
```

- Prefer **PDF/SVG** for vector graphics (sharp text/lines).
- Use high **DPI** for rasters.
- `transparent=True` for slides over colored backgrounds.

---

## Key terms (quick glossary)

- **Locator**: chooses tick positions.
- **Formatter**: converts tick values to strings.
- **Norm**: maps data → [0..1] for colormapping.
- **Spine**: the axis border line.
- **Twin axis**: a second axis sharing the same position with independent scale.
- **Secondary axis**: derived from primary via conversion functions.
- **GridSpec**: flexible subplot layout manager.
- **Inset**: small axes inside another for zoom or context.

---

## Advanced practice (Q&A)

1. When should you choose `symlog` over `log`?
2. Show code to add **minor ticks** every 0.25 on the x-axis and style them
   differently from major ticks.
3. Your y-axis requires scientific notation outside ±1e3. Set it using a
   **formatter**.
4. What’s the difference between `twinx()` and `secondary_yaxis()`? Give a use
   case for each.
5. You need a zoomed **inset** focusing on x ∈ [2, 4], y ∈ [0.5, 1]. Sketch the
   code.
6. Pick a **diverging** colormap for anomalies centered at 0 and normalize
   accordingly.
7. Save a figure for print with minimal whitespace and sharp text. Which format
   and flags?
8. Place axes at (0, 0) crossing with only left and bottom spines shown.
9. Use **GridSpec** to create a layout with one large plot on the left and two
   stacked small plots on the right.
10. For probabilities (0,1), which axis scale is appropriate and how do you
    handle exact 0/1 values?
11. Add a **custom tick formatter** that appends “ ms” to x-tick labels.
12. When would you prefer `imshow` vs `pcolormesh`?
13. Create a 3D **wireframe** and set equal aspect.
14. Set a global style for thicker lines and bigger titles without modifying
    each plot call.
15. How do `tight_layout()` and `constrained_layout` differ? When to prefer
    each?

---

## Answers

1. **`symlog`** for data spanning positive and negative magnitudes; it’s linear
   near 0 (via `linthresh`) and log outside. `log` cannot display ≤0.
2.

```python
ax.xaxis.set_major_locator(mticker.MultipleLocator(1))
ax.xaxis.set_minor_locator(mticker.MultipleLocator(0.25))
ax.tick_params(axis='x', which='major', length=7, width=1.5)
ax.tick_params(axis='x', which='minor', length=3, color='0.5')
```

3.

```python
sf = mticker.ScalarFormatter(useMathText=True)
sf.set_powerlimits((-3, 3))
ax.yaxis.set_major_formatter(sf)
```

4. `twinx()` creates an **independent** secondary scale sharing the same x; use
   when variables have different units (e.g., °C vs mm). `secondary_yaxis()` is
   a **functionally linked** transform (e.g., °C ↔ °F).
5.

```python
ins = inset_axes(ax, width="35%", height="35%", loc='upper right')
ins.plot(x, y)
ins.set_xlim(2, 4); ins.set_ylim(0.5, 1)
mark_inset(ax, ins, loc1=2, loc2=4, fc="none", ec="0.5")
```

6.

```python
from matplotlib.colors import TwoSlopeNorm
norm = TwoSlopeNorm(vcenter=0)
cs = ax.contourf(XX, YY, Z, levels=21, cmap='RdBu_r', norm=norm)
fig.colorbar(cs, ax=ax)
```

7. Save as **PDF** (vector) or high-DPI PNG:

```python
fig.savefig('plot.pdf', bbox_inches='tight', pad_inches=0.02)
```

8.

```python
for side in ('top','right'):
    ax.spines[side].set_visible(False)
ax.spines['left'].set_position('zero')
ax.spines['bottom'].set_position('zero')
ax.yaxis.set_ticks_position('left')
ax.xaxis.set_ticks_position('bottom')
```

9.

```python
gs = gridspec.GridSpec(2, 3, figure=fig)
ax_big   = fig.add_subplot(gs[:, :2])
ax_top   = fig.add_subplot(gs[0, 2])
ax_bottom= fig.add_subplot(gs[1, 2])
```

10. Use **`logit`** scale on (0,1); avoid exact 0/1 by clipping:

```python
p = np.clip(p, 1e-6, 1-1e-6)
ax.set_yscale('logit')
```

11.

```python
ax.xaxis.set_major_formatter(mticker.FuncFormatter(lambda v, pos: f'{v:.0f} ms'))
```

12. `imshow` for regular pixel grids (fast), `pcolormesh` for cell-based or
    irregular grids and when you need edge control.
13.

```python
ax.plot_wireframe(x, y, z, rstride=2, cstride=2)
ax.set_box_aspect([1,1,1])
```

14.

```python
plt.style.use('default')
mpl.rcParams.update({'lines.linewidth': 2.5, 'axes.titlesize': 14})
```

15. `tight_layout()` quickly adjusts subplot params to prevent overlap.
    `constrained_layout` is a **layout engine** that considers colorbars/labels
    more holistically—prefer it for complex, nested layouts.

---

### What to explore next

- `matplotlib.dates` for time series
- `matplotlib.animation.FuncAnimation` for animated plots
- `matplotlib.transforms` for coordinate systems and precise annotations
- Seaborn & plotnine for higher-level statistical graphics

You’re now equipped to make **clear, expressive, and robust** figures — from
exploratory analysis to final publication.
