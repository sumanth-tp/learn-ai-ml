---
title: DataFrames - Part 3 MultiIndex and Hierarchical Indexing
sidebar_label: DataFrames - Part 3
sidebar_position: 5
---

## Introduction

A **MultiIndex** (hierarchical index) allows a DataFrame or Series to be indexed by **more than one key**. Conceptually, it’s like a tree:

* Level 0 (outer) → broad grouping (e.g., Group, Country, Year)
* Level 1 (inner) → finer grouping within each outer key (e.g., Item, City, Quarter)
* … and so on

Why MultiIndex matters:

* Represents **naturally nested data** without exploding column counts.
* Enables **powerful slicing**, **cross-sections**, **reshaping** (`stack`/`unstack`), **grouped aggregations**, and **time-series rollups**.
* Keeps metadata (level names) so selections remain **semantic** and readable.

---

## Constructing a MultiIndexed DataFrame

### From tuples with `pd.MultiIndex.from_tuples`

```python
import numpy as np
import pandas as pd

np.random.seed(101)

outside = ['G1','G1','G1','G2','G2','G2']
inside  = [1, 2, 3, 1, 2, 3]
tuples  = list(zip(outside, inside))

index = pd.MultiIndex.from_tuples(tuples)  # 2-level index
df = pd.DataFrame(np.random.randn(6, 2), index=index, columns=['a','b'])
df.index.names = ['groups', 'numb']        # name the levels (recommended)
```

**What you get**

* Level `"groups"`: `G1`, `G2`
* Level `"numb"`: `1, 2, 3`
* Columns: `a`, `b`

### Other common ways to build MultiIndex

* **From product** of iterables:

  ```python
  arrays = pd.MultiIndex.from_product([['G1','G2'], [1,2,3]], names=['groups','numb'])
  df2 = pd.DataFrame(np.random.randn(6, 2), index=arrays, columns=['a','b'])
  ```

* **From columns with `set_index` (multiple columns)**:

  ```python
  raw = pd.DataFrame({
      'group': ['G1','G1','G1','G2','G2','G2'],
      'numb':  [1,2,3,1,2,3],
      'a': np.random.randn(6),
      'b': np.random.randn(6),
  })
  df3 = raw.set_index(['group','numb']).sort_index()
  df3.index.names = ['groups','numb']
  ```

* **MultiIndex on columns** (common after pivots):

  ```python
  cols = pd.MultiIndex.from_product([['measure'], ['a','b']], names=['kind','var'])
  df_cols = pd.DataFrame(np.random.randn(6,2), index=index, columns=cols)
  ```

---

## Accessing Data (Outside → Inside)

### `.loc` with stepwise selection

```python
# All rows for outer label 'G1'
df.loc['G1']              # returns a smaller DataFrame indexed by 'numb'

# A single row: outer 'G1', inner 1
df.loc['G1'].loc[1]       # returns a Series (row at ('G1', 1))

# Equivalent one-shot tuple selection
df.loc[('G1', 1)]
```

**Rule of thumb**: With MultiIndex on rows, **tuples** select across levels in one go: `df.loc[(outer, inner, ...)]`.

### Selecting specific scalar values

```python
# Value at groups='G2', numb=2, column='b'
df.loc[('G2', 2), 'b']
```

---

## Naming and Inspecting Index Levels

```python
df.index.names              # -> ['groups','numb']
df.index.get_level_values('groups')  # array-like of outer labels
df.index.get_level_values(1)         # by position
```

Naming levels is crucial for readable code and for level-specific operations (e.g., with `xs`, `swaplevel`, `sort_index(level=...)`).

---

## Cross-Section Selection with `xs`

`xs` = cross-section selector. It’s concise and can **target a specific level** regardless of its position.

```python
# All rows where 'groups' == 'G1'
df.xs('G1', level='groups')

# All rows where 'numb' == 1 across all groups
df.xs(1, level='numb')

# Drill into columns if they are MultiIndexed (example when columns are multi-level):
# df.xs(('measure','a'), axis=1)  # select the ('measure','a') column
```

**Tip**: `xs` has `drop_level=` (Pandas ≥ 1.5) to keep or drop the level used for selection:

```python
df.xs(1, level='numb', drop_level=False)
```

---

## Boolean Filtering with MultiIndex

Boolean filters operate on the DataFrame values, independent of the index structure.

```python
# Keep rows (any level) where column 'a' > 0
df[df['a'] > 0]

# Keep rows where groups == 'G2' (by boolean mask on index level)
mask = df.index.get_level_values('groups') == 'G2'
df[mask]
```

---

## Slicing MultiIndex with `.loc` and `pd.IndexSlice`

### Requirements

* The MultiIndex must be **sorted** on the levels you slice across:

  ```python
  df = df.sort_index()
  ```

### Clean slicing syntax

```python
idx = pd.IndexSlice

# All rows for G1, numb from 2 to 3 (inclusive)
df.loc[idx['G1', 2:3], :]

# All groups, only numb == 1
df.loc[idx[:, 1], :]

# All groups, numb in [1,3], select only column 'b'
df.loc[idx[:, [1,3]], 'b']
```

---

## Reshaping with `stack` / `unstack`

`stack` moves a column level to the row index.
`unstack` moves a row level to columns.

```python
# Move inner row level 'numb' to columns
wide = df.unstack(level='numb')         # columns become MultiIndex ('a','b') × numb
# Move it back
long = wide.stack(level='numb')         # returns to original shape

# Specify column level to stack/unstack when columns are MultiIndexed
# df_cols.unstack('var') / df_cols.stack('kind')
```

Use `unstack` to **pivot** a level to columns (great for reporting), and `stack` to **normalize** wide data to long.

---

## Reordering & Sorting Levels

* **Swap adjacent levels**:

  ```python
  df_swapped = df.swaplevel('groups', 'numb')  # just reorders the index levels
  ```

* **Sort by a specific level** (enables proper slicing):

  ```python
  df_sorted = df.sort_index(level=['groups','numb'])
  ```

* **Reorder levels arbitrarily**:

  ```python
  df_reordered = df.reorder_levels(['numb','groups'])
  ```

---

## Resetting and (Re-)Building MultiIndex

```python
# Flatten index back to columns
flat = df.reset_index()                       # columns: groups, numb, a, b

# Build multiindex again (possibly with different order)
back = flat.set_index(['groups', 'numb']).sort_index()
```

**Adding a new level**:

```python
flat['rep'] = [1,1,1,2,2,2]                   # new grouping
df_3lvl = flat.set_index(['groups','numb','rep']).sort_index()
df_3lvl.index.names = ['groups','numb','rep']
```

---

## MultiIndex on Columns (Wide Tables)

Common after `pivot_table`, `groupby.agg`, or manual creation.

```python
arrays = pd.MultiIndex.from_product([['mean','std'], ['a','b']], names=['stat','var'])
dfc = pd.DataFrame(np.random.randn(6,4), index=df.index, columns=arrays)

# Select a single block
dfc['mean']          # columns reduced to ('a','b') under 'mean'
dfc.xs('a', level='var', axis=1)  # all stats for column 'a'

# Flatten columns after aggregation/pivot:
dfc.columns = ['{}_{}'.format(s, v) for s, v in dfc.columns.to_flat_index()]
```

---

## Aggregations by Level (Groupby-like without splitting)

When your data are already organized in a MultiIndex, you can aggregate across **levels** directly:

```python
# Sum across inner level 'numb' → one row per 'groups'
df_sum_groups = df.groupby(level='groups').sum()

# Mean across outer level 'groups' → one row per 'numb'
df_mean_numb = df.groupby(level='numb').mean()

# With multiple functions on columns → MultiIndex columns appear
agg = df.groupby(level='groups').agg(['mean','std'])
```

---

## Practical Patterns and Pitfalls

* **Always name levels** (`df.index.names = [...]`). It makes code readable and unlocks `level='name'` selections.
* **Sort index** before slicing ranges with `.loc` + `IndexSlice`.
* Use **tuple keys** with `.loc` to select across multiple levels in one step (`df.loc[('G2', 3), 'a']`).
* Prefer **`xs`** when you want a cross-section by a single level without writing masks or nested `.loc`.
* After `groupby(...).agg(...)` or `pivot_table`, expect **MultiIndex columns**; flatten if needed for export or modeling.
* Beware **chained indexing** with MultiIndex (e.g., `df['a']['b']` on columns) — prefer `.loc` with tuples or `xs`.
* Use **`get_level_values`** for vectorized operations or boolean masks based on index metadata.
* When sharing data downstream (CSV/Excel), consider **flattening** MultiIndex columns to single-level names.

---

## Beginner Examples (Step by Step)

### 1) Build and name a MultiIndex

```python
outside = ['G1','G1','G1','G2','G2','G2']
inside  = [1,2,3,1,2,3]
tuples  = list(zip(outside, inside))
idx     = pd.MultiIndex.from_tuples(tuples, names=['groups','numb'])

df = pd.DataFrame(np.random.randn(6, 2), index=idx, columns=['a','b'])
```

### 2) Read and select

```python
df.loc['G1']          # rows for G1
df.loc[('G1', 2)]     # row at (G1, 2)
df.loc[('G2', 3), 'a']  # scalar
```

### 3) Cross-sections

```python
df.xs('G1', level='groups')
df.xs(1, level='numb')    # all rows where numb == 1
```

### 4) Slice ranges (ensure sorted)

```python
df = df.sort_index()
idx = pd.IndexSlice
df.loc[idx['G1', 2:3], :]     # numb 2..3 for group G1
```

---

## Advanced Examples

### A) Combine `xs` with post-filter and column selection

```python
# All 'numb' == 2 across groups, then keep rows where 'a' > 0, and only column 'b'
block = df.xs(2, level='numb')
res = block[block['a'] > 0][['b']]
```

### B) Reshape for reporting: `unstack` inner level to columns

```python
wide = df.unstack('numb')        # columns become MultiIndex ('a'/'b') × numb
# Example: compute per-numb z-score of column 'a'
a_block = wide['a']              # columns: numb 1..3
a_z = (a_block - a_block.mean()) / a_block.std()
```

### C) MultiIndex on columns after aggregation, then flatten

```python
agg = df.groupby(level='groups').agg(['mean','std'])  # MultiIndex columns
agg.columns = ['{}_{}'.format(col, stat) for col, stat in agg.columns.to_flat_index()]
# Columns now like: a_mean, a_std, b_mean, b_std
```

### D) Reorder and slice with `IndexSlice` across levels

```python
df2 = df.reorder_levels(['numb','groups']).sort_index()
idx = pd.IndexSlice
df2.loc[idx[1:2, :], :]      # all groups, numb in [1,2]
```

### E) Time-like hierarchy: Year × Quarter

```python
years = [2023,2023,2023,2023,2024,2024,2024,2024]
qtrs  = ['Q1','Q2','Q3','Q4']*2
mi    = pd.MultiIndex.from_arrays([years, qtrs], names=['year','quarter'])
ts    = pd.DataFrame({'sales': np.random.randint(100,200,size=8)}, index=mi).sort_index()

# Yearly total and quarterly pivot
year_total = ts.groupby(level='year').sum()
pivot_qtr  = ts.unstack('quarter')      # quarters to columns
```

### F) Align and fill across levels (reindex with product)

```python
full_idx = pd.MultiIndex.from_product([['G1','G2'], [1,2,3,4]], names=['groups','numb'])
df_full  = df.reindex(full_idx)         # adds numb=4 as NaN
df_full['a'] = df_full['a'].fillna(0.0)
```

---

## Practice Questions

1. Explain the conceptual difference between a single-level index and a MultiIndex on rows.
2. Create a 2-level MultiIndex DataFrame for groups `['G1','G2']` and numbers `[1,2,3]` with columns `['a','b']`, then name the levels.
3. Write three equivalent ways to select the row at group `'G2'`, numb `2`.
4. Using `xs`, select all rows where the inner level (named `'numb'`) equals `1`, regardless of group.
5. Show how to slice rows for `'G1'` where `numb` is in the closed range `[2,3]` using `.loc` and `pd.IndexSlice`. Assume the index is sorted.
6. Unstack the inner level `'numb'` to columns and extract only the `'a'` block from the resulting wide DataFrame.
7. After `groupby(level='groups').agg(['mean','std'])`, you get MultiIndex columns. Write code to flatten these columns to single strings like `a_mean`, `a_std`, `b_mean`, `b_std`.
8. Demonstrate how to **add** a third index level `'rep'` with values `[1,1,1,2,2,2]` to the existing 2-level DataFrame (groups×numb).
9. What does `swaplevel('groups','numb')` do, and why might you follow it with `sort_index()`?
10. Given a MultiIndex DataFrame `df` (levels `'groups','numb'`), write a boolean filter that keeps only rows where `'groups' == 'G1'` using the index metadata (not the values in any column).

---

## Answers

1. **Single-level index** uses one key per row; **MultiIndex** uses a tuple of keys (levels). MultiIndex represents nested/ hierarchical groupings and enables level-aware slicing, reshaping, and aggregation.
2. ```python
   import numpy as np, pandas as pd
   idx = pd.MultiIndex.from_product([['G1','G2'], [1,2,3]], names=['groups','numb'])
   df = pd.DataFrame(np.random.randn(6,2), index=idx, columns=['a','b'])
   ```
3. ```python
   df.loc[('G2', 2)]
   df.loc['G2'].loc[2]
   df.xs('G2', level='groups').loc[2]
   ```
4. ```python
   df.xs(1, level='numb')
   ```
5. ```python
   df = df.sort_index()
   idx = pd.IndexSlice
   df.loc[idx['G1', 2:3], :]
   ```
6. ```python
   wide = df.unstack('numb')  # MultiIndex columns ('a','b') × numb
   a_wide = wide['a']
   ```
7. ```python
   agg = df.groupby(level='groups').agg(['mean','std'])
   agg.columns = ['{}_{}'.format(col, stat) for col, stat in agg.columns.to_flat_index()]
   ```
8. ```python
   flat = df.reset_index()                    # columns: groups, numb, a, b
   flat['rep'] = [1,1,1,2,2,2]
   df3 = flat.set_index(['groups','numb','rep']).sort_index()
   df3.index.names = ['groups','numb','rep']
   ```
9. `swaplevel('groups','numb')` **reorders the index levels** (inner↔outer). You often call `sort_index()` afterwards so range slicing by the (new) outer level works correctly and efficiently.
10. ```python
    mask = df.index.get_level_values('groups') == 'G1'
    df_g1 = df[mask]
    ```
