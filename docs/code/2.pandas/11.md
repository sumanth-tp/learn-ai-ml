---

title: Pandas - One shot
sidebar_label: Pandas (YT)
sidebar_position: 11
--------------------

## Introduction

**Pandas** is one of the most powerful and widely used libraries in **Python** for **data analysis**, **data manipulation**, and **machine learning preprocessing**.
It is built on top of **NumPy**, meaning it inherits fast numerical operations while adding more powerful tools for working with **tabular (spreadsheet-like)** data.

The name **Pandas** comes from **“Panel Data”**, not the panda animal 🐼 (though that’s a fun coincidence).

In simple terms, **Pandas = Excel in Python, but far more powerful**.

---

## Why Use Pandas?

Pandas allows you to:

- Load, clean, explore, and analyze datasets efficiently.
- Perform operations like filtering, grouping, and aggregation with just a few
  lines of code.
- Handle large datasets that Excel cannot.
- Integrate seamlessly with **NumPy**, **Matplotlib**, **SQL**, and **machine
  learning libraries** like **scikit-learn**.

---

## Installing and Importing Pandas

Before using Pandas, you need to install it:

```bash
pip install pandas
```

Once installed, import it into your Python program:

```python
import pandas as pd
```

Here, `pd` is the **alias** (a shorter nickname) for Pandas — a common
convention used by all Python developers.

To check your Pandas version:

```python
print(pd.__version__)
```

---

## Pandas Data Structures: The Core Concepts

Pandas provides two key data structures:

### 1. **Series**

- A **one-dimensional labeled array**.
- Think of it as a **single column** in Excel.
- Each value has a label called an **index**.

**Example:**

```python
import pandas as pd
my_data = [100, 102, 104]
ser = pd.Series(my_data)
print(ser)
```

**Output:**

```
0    100
1    102
2    104
dtype: int64
```

- The **left column** shows **index labels** (0, 1, 2).
- The **right column** shows **data values** (100, 102, 104).
- The `dtype` shows the **data type** of elements (`int64` here).

---

### 2. **DataFrame**

- A **two-dimensional table** — like an Excel sheet.
- Each column is a `Series` with its own label.
- Rows and columns both have labels (index and column names).

**Example:**

```python
data = {
    'Name': ['Spongebob', 'Patrick', 'Squidward'],
    'Age': [30, 35, 50],
}
df = pd.DataFrame(data)
print(df)
```

**Output:**

```
        Name  Age
0  Spongebob   30
1    Patrick   35
2  Squidward   50
```

- Each column (like “Name” or “Age”) is a **Series**.
- The table has both **row indices** and **column labels**.

---

## Understanding the Basics: Series in Depth

### Creating a Series

```python
data = [100, 102, 104]
ser = pd.Series(data)
```

To create a custom index:

```python
ser = pd.Series(data, index=['A', 'B', 'C'])
print(ser)
```

**Output:**

```
A    100
B    102
C    104
dtype: int64
```

---

### Accessing Values

#### By Label

```python
ser.loc['A']
# Output: 100
```

#### By Position

```python
ser.iloc[0]
# Output: 100
```

**Keyword meanings:**

| Keyword | Meaning                          | Used For                        |
| ------- | -------------------------------- | ------------------------------- |
| `loc`   | location by **label**            | Named index (e.g., 'A', 'B')    |
| `iloc`  | location by **integer position** | Numerical index (e.g., 0, 1, 2) |

---

### Updating Values

```python
ser.loc['C'] = 200
print(ser)
```

**Output:**

```
A    100
B    102
C    200
dtype: int64
```

---

### Filtering Data in a Series

Return values greater than or equal to 200:

```python
ser[ser >= 200]
```

**Output:**

```
C    200
dtype: int64
```

---

### Creating Series from a Dictionary

```python
calories = {'Day1': 1750, 'Day2': 2100, 'Day3': 1700}
ser = pd.Series(calories)
print(ser)
```

**Output:**

```
Day1    1750
Day2    2100
Day3    1700
dtype: int64
```

You can access, update, or filter the same way:

```python
ser.loc['Day3'] += 500
print(ser)
```

---

## Understanding the Basics: DataFrames in Depth

A **DataFrame** is a **collection of multiple Series** sharing a common index.

### Creating a DataFrame from a Dictionary

```python
data = {
    'Name': ['Spongebob', 'Patrick', 'Squidward'],
    'Age': [30, 35, 50]
}
df = pd.DataFrame(data, index=['Employee1', 'Employee2', 'Employee3'])
print(df)
```

**Output:**

```
               Name  Age
Employee1  Spongebob   30
Employee2    Patrick   35
Employee3  Squidward   50
```

---

### Selecting Rows and Columns

#### Selecting a Column

```python
df['Name']
```

#### Selecting Multiple Columns

```python
df[['Name', 'Age']]
```

#### Selecting a Row by Label

```python
df.loc['Employee2']
```

#### Selecting a Row by Position

```python
df.iloc[1]
```

---

### Adding a New Column

```python
df['Job'] = ['Cook', 'NA', 'Cashier']
```

### Adding a New Row

```python
new_row = pd.DataFrame([{'Name': 'Sandy', 'Age': 28, 'Job': 'Engineer'}],
                       index=['Employee4'])
df = pd.concat([df, new_row])
```

---

## Common File Operations

### Reading a CSV File

```python
df = pd.read_csv('data.csv')
```

### Reading a JSON File

```python
df = pd.read_json('data.json')
```

### Writing to a CSV File

```python
df.to_csv('output.csv', index=False)
```

---

## Filtering and Selection

You can filter rows based on a condition:

```python
tall_pokemon = df[df['Height'] >= 2]
heavy_pokemon = df[df['Weight'] > 100]
```

You can also filter with logical operators:

```python
fire_flying = df[(df['Type1'] == 'Fire') & (df['Type2'] == 'Flying')]
```

---

## Aggregation Functions

Aggregation reduces multiple values to a single summary value.

| Function  | Description               |
| --------- | ------------------------- |
| `mean()`  | Average                   |
| `sum()`   | Total                     |
| `min()`   | Minimum                   |
| `max()`   | Maximum                   |
| `count()` | Number of non-null values |

Example:

```python
df['Height'].mean()
df['Weight'].sum()
```

Group by category:

```python
df.groupby('Type1')['Height'].mean()
```

---

## Data Cleaning Essentials

Data cleaning fixes **missing**, **inconsistent**, or **irrelevant** data.

### 1. Drop Irrelevant Columns

```python
df = df.drop(columns=['Legendary'])
```

### 2. Drop Missing Values

```python
df = df.dropna(subset=['Type2'])
```

### 3. Replace Missing Values

```python
df['Type2'] = df['Type2'].fillna('None')
```

### 4. Fix Inconsistent Text

```python
df['Type1'] = df['Type1'].replace({'grass': 'GRASS', 'fire': 'FIRE'})
```

### 5. Convert Data Type

```python
df['Legendary'] = df['Legendary'].astype(bool)
```

### 6. Remove Duplicates

```python
df = df.drop_duplicates()
```

---

## Key Takeaways

- **Series** = single labeled column
- **DataFrame** = multiple Series combined into a table
- **loc / iloc** allow powerful selection by label or index
- **Aggregation functions** summarize data
- **Data cleaning** ensures accuracy and consistency
- **Pandas** can read/write data to multiple formats: CSV, Excel, JSON, SQL

---

## Practice Questions

1. What is the difference between a Series and a DataFrame?
2. How do you create a Series with custom labels?
3. What’s the difference between `.loc` and `.iloc`?
4. How do you filter all rows where “Age” > 30?
5. How can you read a CSV file into Pandas?
6. Write a command to remove missing values in “Type2”.
7. How do you calculate the average height of all Pokémon?
8. How do you append a new employee record to a DataFrame?

---

## Answers

1. A **Series** is one-dimensional; a **DataFrame** is two-dimensional (rows +
   columns).
2. ```python
   pd.Series([10, 20, 30], index=['A', 'B', 'C'])
   ```
3. `.loc` uses labels; `.iloc` uses numerical positions.
4. ```python
   df[df['Age'] > 30]
   ```
5. ```python
   pd.read_csv('filename.csv')
   ```
6. ```python
   df.dropna(subset=['Type2'])
   ```
7. ```python
   df['Height'].mean()
   ```
8. ```python
   df.loc['Employee4'] = ['Sandy', 28, 'Engineer']
   ```
