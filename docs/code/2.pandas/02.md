---
title: "Series"
sidebar_label: "Series"
sidebar_position: 2
---

# Pandas Series: Introduction and Fundamentals

## What is a Pandas Series?

A **Pandas Series** is a **one-dimensional labeled array** that can hold any
data type such as integers, floats, strings, Python objects, or even functions.

- It is **built on top of NumPy arrays**, which means it inherits the efficiency
  of NumPy (fast operations, vectorization).
- What differentiates a Pandas Series from a NumPy array is the presence of an
  **index**.
- The **index** acts as labels for the data, allowing you to retrieve data more
  intuitively (like a dictionary) instead of relying only on integer positions.

Think of a Series as a **cross between a dictionary and a NumPy array**:

- Like a NumPy array, it supports efficient numerical operations.
- Like a dictionary, it allows key-based (label-based) lookups.

---

## Why Series Matter?

Series are the **building blocks of DataFrames**:

- A DataFrame is essentially a collection of Series objects that share the same
  index.
- Understanding Series is crucial to mastering Pandas, because **every DataFrame
  column is a Series**.

---

## Creating a Pandas Series

To use Pandas, import it (along with NumPy for arrays):

```python
import numpy as np
import pandas as pd
```

### Example Objects

```python
labels = ['A', 'B', 'C']              # list of labels
my_data = [10, 20, 30]                # list of data
arr = np.array(my_data)               # NumPy array
d = {'A': 10, 'B': 20, 'C': 30}       # dictionary
```

Here we have:

- `labels`: standard Python list of strings
- `my_data`: Python list of numbers
- `arr`: NumPy array version of the list
- `d`: dictionary mapping keys → values

---

## Constructing Series from Different Objects

### 1. From a List

```python
pd.Series(data=my_data)
```

Output:

```
0    10
1    20
2    30
dtype: int64
```

- By default, Pandas assigns integer indexes `0,1,2`.
- Data values are `10,20,30`.

---

### 2. With Custom Index

```python
pd.Series(data=my_data, index=labels)
```

Output:

```
A    10
B    20
C    30
dtype: int64
```

Here:

- `'A','B','C'` are used as custom labels.
- This makes the Series **more meaningful** than just positional indexes.

Shortcut (since data and index are expected in order):

```python
pd.Series(my_data, labels)
```

---

### 3. From a NumPy Array

```python
pd.Series(arr)
```

Output:

```
0    10
1    20
2    30
dtype: int64
```

Since arrays already have positions, Pandas uses them as the default index.

You can also assign custom labels:

```python
pd.Series(arr, index=labels)
```

---

### 4. From a Dictionary

```python
pd.Series(d)
```

Output:

```
A    10
B    20
C    30
dtype: int64
```

Here:

- Keys (`'A','B','C'`) become the **index**.
- Values (`10,20,30`) become the **data**.

---

## Series Can Hold Various Data Types

Unlike NumPy arrays (which prefer a single type), Series can hold
**heterogeneous types**.

### Strings

```python
pd.Series(labels)
```

Output:

```
0    A
1    B
2    C
dtype: object
```

### Functions

```python
pd.Series([sum, print, len])
```

Output:

```
0      <built-in function sum>
1      <built-in function print>
2      <built-in function len>
dtype: object
```

This flexibility allows Series to represent more than just numbers.

---

## Indexing in Series

The **index** is the most important feature of Series. It allows **fast lookup
and alignment** of data.

### Example

```python
ser1 = pd.Series([1, 2, 3, 4], index=['USA', 'Germany', 'USSR', 'Japan'])
ser2 = pd.Series([1, 2, 5, 4], index=['USA', 'Germany', 'Italy', 'Japan'])
```

Here:

- `ser1` and `ser2` both store country-based values.
- The index allows retrieval just like a dictionary:

```python
ser1['USA']   # returns 1
```

If the index is numeric:

```python
ser3 = pd.Series(labels)  # ['A','B','C']
ser3[0]                   # returns 'A'
```

Indexes make Series behave like a **dictionary + array hybrid**.

---

## Basic Operations with Series

Operations are **index-aligned**, meaning they match based on labels, not
position.

```python
ser1 + ser2
```

Output:

```
Germany    4.0
Italy      NaN
Japan      8.0
USA        2.0
USSR       NaN
dtype: float64
```

Explanation:

- `'USA'`: `1+1 = 2`
- `'Germany'`: `2+2 = 4`
- `'Japan'`: `4+4 = 8`
- `'Italy'` exists only in `ser2` → `NaN`
- `'USSR'` exists only in `ser1` → `NaN`

### Why float?

Even though inputs are integers, Pandas promotes to float (`NaN` is a float
placeholder). This avoids losing information during operations like division.

---

## Theory Recap

- **Series = labeled one-dimensional array**.
- **Difference from NumPy**: has labels (index).
- **Can be created from**: lists, arrays, dictionaries.
- **Supports multiple data types** (numbers, strings, functions).
- **Indexing** works like dictionary keys.
- **Operations** align data on index labels, missing data → `NaN`.

---

## Key Takeaways

1. A Pandas Series is similar to a NumPy array, but with **labels (indexes)**.
2. You can create Series from lists, arrays, or dictionaries.
3. A Series can store multiple types of objects, not just numbers.
4. Index-based access is faster and more flexible than relying only on position.
5. Operations align automatically on **labels**, not positions.

---

## Practice Questions

1. Explain how a Pandas Series is different from a NumPy array.
2. Create a Series with labels `['Math','Science','English']` and scores
   `[90,85,95]`.
3. What happens when two Series are added but have different indexes?
4. Why does Pandas use `NaN` for missing labels in operations?
5. Write code to create a Series from a dictionary of countries and populations.

---
