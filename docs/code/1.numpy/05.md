---

title: NumPy Operations
sidebar_label: NumPy Operations
sidebar_position: 15
--------------------

## Introduction

In this lecture, we explore **NumPy operations** ‚Äî how to perform mathematical calculations efficiently on arrays.
NumPy is designed for **vectorized computation**, meaning that mathematical operations apply to **entire arrays at once** rather than looping through individual elements.

This section covers:

* Array-to-array operations
* Array-to-scalar operations
* Division behavior in NumPy
* Exponentiation
* Universal array functions (**ufuncs**)

---

## 1. Setting Up the Array

Let‚Äôs start by creating a simple array from 0 to 10:

```python
import numpy as np
array = np.arange(0, 11)
print(array)
```

**Output:**

```
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10])
```

This creates a one-dimensional NumPy array with **11 elements** (from 0 to 10
inclusive).

---

## 2. Array-to-Array Operations

In NumPy, you can perform **element-wise arithmetic** directly between arrays.
Each operation is performed **on corresponding elements**.

```python
array + array   # Adds each element to itself
array - array   # Subtracts element-wise
array * array   # Multiplies element-wise
```

**Example:**

```python
print(array + array)
# Output: [ 0  2  4  6  8 10 12 14 16 18 20]
```

This behavior is far more efficient than looping through lists in Python.

---

### ‚öôÔ∏è Behind the Scenes: Vectorization

- NumPy performs these operations using **compiled C code**, not Python loops.
- This makes array operations **100x faster** than native Python lists.
- Every operation automatically **broadcasts** across all elements in the array.

---

## 3. Array-to-Scalar Operations

NumPy arrays also support operations with **scalars** (single numeric values).
When a scalar interacts with an array, NumPy **broadcasts** the scalar to every
element.

```python
array + 100   # Adds 100 to each element
array - 100   # Subtracts 100 from each element
array * 2     # Doubles each element
array / 2     # Halves each element
```

**Output Example:**

```python
array * 2
# Output: [ 0  2  4  6  8 10 12 14 16 18 20]
```

This automatic ‚Äúbroadcasting‚Äù is one of the most powerful features of NumPy.

---

### üîç Keyword Explanation: **Broadcasting**

Broadcasting is a mechanism that allows NumPy to **automatically expand arrays**
during arithmetic operations.

- When two arrays (or an array and a scalar) differ in size or shape, NumPy
  ‚Äúbroadcasts‚Äù the smaller one across the larger so that they match
  dimensionally.
- Example:

  ```python
  np.array([1,2,3]) + 10
  # Output: [11, 12, 13]
  ```

---

## 4. Division by Zero in NumPy

In standard Python:

```python
1 / 0
# Raises ZeroDivisionError
```

But in NumPy, dividing by zero **does not stop execution**. Instead, it issues a
**warning** and returns **special values**:

- `nan` ‚Üí ‚ÄúNot a Number‚Äù
- `inf` ‚Üí Infinity

**Example:**

```python
array / array
```

**Output:**

```
RuntimeWarning: invalid value encountered in divide
array([nan, 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])
```

Explanation:

- The first element is `0/0` ‚Üí `nan`
- All others are `n/n` ‚Üí `1`

---

### Scalar Division Example

```python
1 / 0
# RuntimeWarning: divide by zero encountered in scalar divide
# Output: inf
```

NumPy prefers to **warn and continue** instead of raising a fatal error ‚Äî very
useful for scientific computing.

---

## 5. Exponentiation

You can raise each element in an array to a power using the exponentiation
operator `**`.

```python
array ** 2   # Squares every element
array ** 3   # Cubes every element
```

**Output:**

```
array([  0,   1,   4,   9,  16,  25,  36,  49,  64,  81, 100])
```

---

## 6. Universal Array Functions (ufuncs)

### üîç Keyword: **ufunc (Universal Function)**

A _ufunc_ is a function that operates **element-wise** on arrays and supports
**vectorized operations**. They are implemented in **C**, making them extremely
fast.

NumPy provides dozens of ufuncs for mathematical, trigonometric, and logical
operations.

---

### Commonly Used ufuncs

| Function    | Description   | Example          |
| ----------- | ------------- | ---------------- |
| `np.sqrt()` | Square root   | `np.sqrt(array)` |
| `np.exp()`  | Exponential   | `np.exp(array)`  |
| `np.max()`  | Maximum value | `np.max(array)`  |
| `np.sin()`  | Sine function | `np.sin(array)`  |
| `np.log()`  | Natural log   | `np.log(array)`  |

---

### Examples

```python
np.sqrt(array)
# Output: [0.         1.         1.41421356 ... 3.16227766]

np.exp(array)
# Output: [1.00000000e+00 2.71828183e+00 ... 5.98741417e+04]

np.max(array)
# Output: 10

np.sin(array)
# Output: [ 0.          0.84147098  0.90929743 ... -0.54402111]

np.log(array)
# Warning: divide by zero encountered in log
# Output: [-inf  0.   0.69314718 ... 2.30258509]
```

> ‚ö†Ô∏è **Note:** `np.log(0)` ‚Üí `-inf` with a runtime warning.

---

### Additional Useful ufuncs

| Function            | Description                 |
| ------------------- | --------------------------- |
| `np.mean()`         | Average of all elements     |
| `np.std()`          | Standard deviation          |
| `np.var()`          | Variance                    |
| `np.abs()`          | Absolute value              |
| `np.power(a, b)`    | Element-wise exponentiation |
| `np.add(a, b)`      | Element-wise addition       |
| `np.multiply(a, b)` | Element-wise multiplication |

All ufuncs are vectorized, meaning they apply instantly across large datasets.

---

## 7. Advanced Example: Chained Operations

You can chain operations and functions together for concise computation:

```python
arr = np.arange(1, 6)
result = np.sqrt(arr ** 2 + np.exp(arr))
print(result)
```

**Explanation:**

- `arr ** 2` squares each number
- `np.exp(arr)` calculates exponentials
- Both arrays are added and then square-rooted element-wise.

---

## 8. Performance Note

NumPy‚Äôs efficiency comes from:

- **Pre-compiled C code** (avoids Python loops)
- **Vectorization**
- **Contiguous memory layout**

This makes mathematical operations on millions of elements **milliseconds fast**
compared to Python lists.

---

## Summary

- NumPy allows **element-wise arithmetic** between arrays and scalars.
- **Broadcasting** automatically expands scalars and smaller arrays to match
  shape.
- **Division by zero** gives warnings instead of stopping execution (`nan`,
  `inf`).
- **Ufuncs** perform vectorized mathematical operations efficiently.
- All operations are fast, memory-efficient, and easy to chain together.

---

## Practice Questions

1. Create a NumPy array from 1 to 10 and add 5 to every element.
2. What is the result of dividing a NumPy array by itself when it contains
   zeros?
3. How does NumPy handle division by zero differently from Python?
4. Compute the exponential of `[0, 1, 2]` using a ufunc.
5. Find the square root and sine of an array `[0, œÄ/2, œÄ]`.
6. Create an array `[1, 2, 3, 4, 5]` and compute `array ** 3 + 10`.
7. What is broadcasting? Give an example.
8. Demonstrate element-wise multiplication of two arrays.
9. Use `np.log()` on `[1, e, e¬≤]` and interpret the result.
10. Create a random array of 10 elements and find its mean, max, and min.

---

## Answers

1. ```python
   arr = np.arange(1, 11) + 5
   ```
2. It returns `nan` for zero divided by zero and `1` for all others.
3. NumPy issues warnings (`nan`, `inf`) instead of raising errors.
4. `np.exp([0, 1, 2])` ‚Üí `[1.0, 2.718, 7.389]`
5. ```python
   arr = np.array([0, np.pi/2, np.pi])
   print(np.sqrt(arr))  # Square roots
   print(np.sin(arr))   # Sine values
   ```
6. `np.array([1,2,3,4,5]) ** 3 + 10` ‚Üí `[11, 18, 37, 74, 135]`
7. Broadcasting allows automatic expansion ‚Äî e.g., `np.array([1,2,3]) + 10` ‚Üí
   `[11,12,13]`.
8. ```python
   np.array([1,2,3]) * np.array([4,5,6])  # Output: [4,10,18]
   ```
9. ```python
   np.log([1, np.e, np.e**2])  # Output: [0, 1, 2]
   ```
10.

```python
arr = np.random.rand(10)
arr.mean(), arr.max(), arr.min()
```
