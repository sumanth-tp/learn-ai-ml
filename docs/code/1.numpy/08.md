---

title: NumPy Interview Questions
sidebar_label: NumPy Interview Questions
sidebar_position: 18
--------------------


# Top 100 NumPy Interview Questions

---

## **Beginner Level (1â€“20)**

### 1. What is NumPy and why is it important?

**Answer:** NumPy (Numerical Python) is a library for efficient numerical
computations. It provides:

- Multi-dimensional array object (`ndarray`)
- Mathematical functions (linear algebra, FFT, statistics, etc.)
- Broadcasting for efficient operations without explicit loops

**Why important?** Almost every Python data science library (Pandas, TensorFlow,
SciPy, etc.) uses NumPy internally.

---

### 2. How do you create a NumPy array?

```python
import numpy as np
arr = np.array([1, 2, 3])
print(arr)
```

- Creates a 1D array.
- Can also create 2D or n-D arrays with nested lists.

---

### 3. What is the difference between `np.array()` and `np.asarray()`?

- `np.array()` always makes a **copy** by default (unless `copy=False`).
- `np.asarray()` avoids copying if the input is already an ndarray.

```python
a = [1,2,3]
arr1 = np.array(a)      # new array (copy)
arr2 = np.asarray(arr1) # no copy, just reference
```

---

### 4. What are `ndim`, `shape`, and `size` in NumPy?

```python
arr = np.array([[1,2,3],[4,5,6]])
print(arr.ndim)   # 2 (2D array)
print(arr.shape)  # (2, 3) â†’ 2 rows, 3 cols
print(arr.size)   # 6 total elements
```

---

### 5. Difference between a Python list and NumPy array?

- **List:** General, can hold different data types, slower for math.
- **NumPy Array:** Homogeneous (all elements same dtype), efficient
  (vectorized).

```python
import time
lst = list(range(1000000))
arr = np.arange(1000000)

# list addition
t1 = time.time(); [x+5 for x in lst]; print("List:", time.time()-t1)

# numpy addition
t1 = time.time(); arr+5; print("Numpy:", time.time()-t1)
```

---

### 6. How do you create arrays with zeros, ones, identity, and custom values?

```python
np.zeros((2,3))         # [[0,0,0],[0,0,0]]
np.ones((2,3))          # [[1,1,1],[1,1,1]]
np.eye(3)               # identity matrix
np.full((2,2), 7)       # [[7,7],[7,7]]
```

---

### 7. How do you generate evenly spaced numbers?

```python
np.arange(0, 10, 2)      # [0 2 4 6 8]
np.linspace(0, 1, 5)     # [0. 0.25 0.5 0.75 1.]
```

- `arange` â†’ step based
- `linspace` â†’ number of samples

---

### 8. How do you create random arrays?

```python
np.random.rand(2,3)          # uniform [0,1)
np.random.randn(2,3)         # normal distribution
np.random.randint(0,10,(2,3))# random ints
```

---

### 9. Explain broadcasting with an example.

Broadcasting allows NumPy to perform arithmetic on arrays of different shapes.

```python
a = np.array([1,2,3])
b = 2
print(a+b)    # [3 4 5]
```

Rule: Dimensions are aligned from the right; size must match or be 1.

---

### 10. How to reshape and flatten arrays?

```python
arr = np.arange(6).reshape(2,3)
print(arr)
# [[0 1 2]
#  [3 4 5]]

arr.flatten()   # copy
arr.ravel()     # view (no copy)
```

---

### 11. How to concatenate and split arrays?

```python
a = np.array([1,2])
b = np.array([3,4])
np.concatenate([a,b])  # [1 2 3 4]
np.vstack([a,b])       # vertical stack
np.hstack([a,b])       # horizontal stack
```

---

### 12. How do you index and slice arrays?

```python
arr = np.array([10,20,30,40,50])
print(arr[1:4])   # [20 30 40]
print(arr[-1])    # 50
```

2D slicing:

```python
mat = np.array([[1,2,3],[4,5,6]])
print(mat[:,1])   # [2 5] â†’ 2nd column
```

---

### 13. How does boolean indexing work?

```python
arr = np.array([10,20,30,40,50])
print(arr[arr>25])   # [30 40 50]
```

Boolean conditions filter values.

---

### 14. Difference between shallow copy (`view`) and deep copy (`copy`)?

```python
arr = np.array([1,2,3])
view = arr.view()    # changes reflect in both
copy = arr.copy()    # independent
```

---

### 15. How to compute basic statistics with NumPy?

```python
arr = np.array([1,2,3,4])
print(arr.mean())   # 2.5
print(arr.std())    # standard deviation
print(arr.var())    # variance
```

---

### 16. How to find min, max, and index of min/max?

```python
arr = np.array([3,7,1,9])
arr.min(), arr.max()     # (1,9)
arr.argmin(), arr.argmax() # (2,3)
```

---

### 17. What is vectorization in NumPy?

Vectorization = applying operations directly on arrays without loops.

```python
arr = np.arange(5)
print(arr*2)    # [0 2 4 6 8]
```

Itâ€™s faster since computations run in C, not Python loops.

---

### 18. How to perform dot product and matrix multiplication?

```python
a = np.array([1,2])
b = np.array([3,4])
print(np.dot(a,b))   # 11

A = np.array([[1,2],[3,4]])
B = np.array([[5,6],[7,8]])
print(A @ B)         # matrix multiplication
```

---

### 19. What is the difference between `np.dot`, `np.matmul`, and `@`?

- `np.dot`: dot product (1D vectors) / matrix multiplication (2D)
- `np.matmul`: strictly matrix multiplication (ignores element-wise)
- `@`: operator alias for `matmul`

---

### 20. How do you save and load NumPy arrays?

```python
np.save("arr.npy", arr)
np.load("arr.npy")

np.savetxt("arr.csv", arr, delimiter=",")
np.loadtxt("arr.csv", delimiter=",")
```

---

# NumPy Interview Questions (Intermediate: 21â€“40)

---

### 21. What are structured arrays in NumPy?

Structured arrays let you store heterogeneous data (like a table).

```python
dt = np.dtype([('name','U10'),('age','i4'),('salary','f4')])
arr = np.array([("Alice",25,50000),("Bob",30,60000)], dtype=dt)
print(arr['name'])   # ['Alice' 'Bob']
```

ðŸ‘‰ Useful for tabular data but less flexible than Pandas.

---

### 22. How do you change the data type of an array?

```python
arr = np.array([1.5, 2.8, 3.6])
arr_int = arr.astype(int)   # [1 2 3]
```

- `.astype()` creates a new array.
- Be careful: can lose precision when converting.

---

### 23. What is the difference between `flatten()` and `ravel()`?

- `flatten()` â†’ returns a **copy** (safe but slower).
- `ravel()` â†’ returns a **view** (faster, memory efficient).

```python
arr = np.arange(6).reshape(2,3)
print(arr.ravel())    # [0 1 2 3 4 5]
print(arr.flatten())  # [0 1 2 3 4 5]
```

---

### 24. How do you find unique values in an array?

```python
arr = np.array([1,2,2,3,3,3])
np.unique(arr)                # [1 2 3]
np.unique(arr, return_counts=True)   # (array([1,2,3]), array([1,1,2]))
```

---

### 25. How do you sort an array?

```python
arr = np.array([3,1,2])
np.sort(arr)          # sorted copy
arr.sort()            # sort in place
np.argsort(arr)       # indices of sorted order
```

---

### 26. How do you select the top-k elements in NumPy?

```python
arr = np.array([10,30,20,40])
idx = np.argsort(arr)[-2:]   # indices of top 2
print(arr[idx])              # [30 40]
```

---

### 27. How do you reverse a NumPy array?

```python
arr = np.array([1,2,3])
print(arr[::-1])     # [3 2 1]
```

---

### 28. How do you reshape without changing data?

```python
arr = np.arange(12)
print(arr.reshape(3,4))
print(arr.reshape(-1,6))   # -1 auto-infers dimension
```

---

### 29. How do you check for NaN or infinity values?

```python
arr = np.array([1, np.nan, np.inf])
np.isnan(arr)    # [False  True False]
np.isinf(arr)    # [False False  True]
```

---

### 30. How do you replace NaN with mean in an array?

```python
arr = np.array([1,2,np.nan,4])
mean = np.nanmean(arr)
arr[np.isnan(arr)] = mean
```

---

### 31. How do you compute cumulative sums and products?

```python
arr = np.array([1,2,3,4])
print(np.cumsum(arr))   # [ 1  3  6 10]
print(np.cumprod(arr))  # [ 1  2  6 24]
```

---

### 32. How do you use `meshgrid`?

Used for creating coordinate matrices for functions.

```python
x = np.array([1,2,3])
y = np.array([10,20])
X, Y = np.meshgrid(x,y)
print(X)
# [[1 2 3]
#  [1 2 3]]
print(Y)
# [[10 10 10]
#  [20 20 20]]
```

---

### 33. How do you generate a diagonal matrix?

```python
arr = np.array([1,2,3])
np.diag(arr)       # [[1,0,0],[0,2,0],[0,0,3]]
```

---

### 34. What is `np.tile` vs `np.repeat`?

```python
arr = np.array([1,2,3])
print(np.tile(arr, 2))    # [1 2 3 1 2 3]
print(np.repeat(arr, 2))  # [1 1 2 2 3 3]
```

- `tile` = repeat entire array
- `repeat` = repeat each element

---

### 35. What is the difference between `np.copy()` and `np.view()`?

- `copy()` â†’ deep copy (independent).
- `view()` â†’ shallow copy (shares memory).

---

### 36. How do you compute correlation and covariance?

```python
x = np.array([1,2,3])
y = np.array([4,5,6])
np.corrcoef(x,y)   # correlation matrix
np.cov(x,y)        # covariance matrix
```

---

### 37. What is the difference between `np.dot` and `*` operator?

```python
a = np.array([1,2])
b = np.array([3,4])
print(a*b)         # element-wise [3 8]
print(np.dot(a,b)) # dot product 11
```

---

### 38. How do you normalize an array?

```python
arr = np.array([1,2,3,4,5])
norm = (arr - arr.min()) / (arr.max() - arr.min())
```

---

### 39. How do you standardize an array?

```python
arr = np.array([1,2,3,4,5])
standardized = (arr - arr.mean()) / arr.std()
```

---

### 40. How to generate reproducible random numbers?

```python
np.random.seed(42)
np.random.randint(0,10,5)
```

- Setting seed ensures the same results across runs.

---

# NumPy Interview Questions (Advanced: 41â€“60)

---

### 41. Explain NumPy broadcasting rules in detail.

Broadcasting aligns shapes **from the right**. Rules:

1. If dimensions differ, the smaller one is padded with `1`.
2. A dimension must be equal or `1` to match.
3. Otherwise â†’ error.

```python
a = np.array([1,2,3])       # shape (3,)
b = np.array([[1],[2]])     # shape (2,1)
print(a+b)   # shape (2,3)
# [[2 3 4]
#  [3 4 5]]
```

---

### 42. What is the difference between `np.newaxis` and `np.expand_dims`?

Both add dimensions.

```python
arr = np.array([1,2,3])
arr[:, np.newaxis].shape         # (3,1)
np.expand_dims(arr, axis=0).shape # (1,3)
```

---

### 43. What are NumPy strides?

- **Stride:** number of bytes to move to the next element in each dimension.
- Explains why `view` and slicing donâ€™t copy data.

```python
arr = np.array([[1,2,3],[4,5,6]])
print(arr.strides)   # e.g. (24, 8) on 64-bit machine
```

---

### 44. How do you use `einsum` in NumPy?

Einstein summation for concise tensor ops.

```python
a = np.array([[1,2],[3,4]])
b = np.array([[5,6],[7,8]])
np.einsum('ij,jk->ik', a, b)   # matrix multiplication
```

ðŸ‘‰ Saves memory by avoiding intermediate arrays.

---

### 45. Difference between `np.allclose` and `np.array_equal`?

- `array_equal` â†’ strict equality
- `allclose` â†’ checks within tolerance (useful for floating-point)

```python
a = np.array([1.0,1.000001])
b = np.array([1.0,1.000002])
np.array_equal(a,b)   # False
np.allclose(a,b)      # True
```

---

### 46. How do you compute eigenvalues and eigenvectors?

```python
A = np.array([[1,2],[2,3]])
vals, vecs = np.linalg.eig(A)
```

- `vals`: eigenvalues
- `vecs`: eigenvectors

---

### 47. Explain SVD (Singular Value Decomposition) in NumPy.

```python
A = np.array([[1,2],[3,4]])
U, S, Vt = np.linalg.svd(A)
```

- Decomposes into `U * S * V^T`.
- Used in PCA, compression, noise reduction.

---

### 48. How do you invert and solve linear systems?

```python
A = np.array([[1,2],[3,4]])
invA = np.linalg.inv(A)

b = np.array([1,2])
x = np.linalg.solve(A,b)   # Ax = b
```

---

### 49. What is the difference between `np.linalg.inv` and `np.linalg.pinv`?

- `inv` â†’ true inverse (only if matrix is square + non-singular).
- `pinv` â†’ pseudo-inverse (Moore-Penrose), works for any shape.

---

### 50. How do you compute the determinant of a matrix?

```python
A = np.array([[1,2],[3,4]])
np.linalg.det(A)   # -2.0
```

---

### 51. What is the difference between `np.dot` and `np.outer`?

```python
a = np.array([1,2])
b = np.array([3,4])
np.dot(a,b)    # scalar â†’ 11
np.outer(a,b)  # [[3 4]
               #  [6 8]]
```

---

### 52. How do you check if a matrix is symmetric or orthogonal?

```python
A = np.array([[1,2],[2,1]])
np.allclose(A, A.T)   # Symmetric?

Q = np.array([[0,-1],[1,0]])
np.allclose(Q@Q.T, np.eye(2))  # Orthogonal?
```

---

### 53. How do you generate random numbers from normal distribution with mean Âµ and std Ïƒ?

```python
np.random.normal(loc=10, scale=2, size=5)
```

---

### 54. Difference between `rand`, `randn`, `random`, `uniform`?

- `rand` â†’ uniform [0,1)
- `randn` â†’ standard normal (Âµ=0, Ïƒ=1)
- `uniform(a,b)` â†’ uniform in [a,b)
- `random()` â†’ uniform [0,1), like `rand`

---

### 55. How do you shuffle and permute arrays?

```python
arr = np.arange(5)
np.random.shuffle(arr)        # in-place
print(np.random.permutation(arr)) # new array
```

---

### 56. How do you sample without replacement?

```python
np.random.choice(10, 5, replace=False)
```

---

### 57. What is `np.mgrid` and `np.ogrid`?

Both generate mesh grids.

- `mgrid` â†’ dense
- `ogrid` â†’ open, memory efficient

```python
np.mgrid[0:3,0:3]    # full grid
np.ogrid[0:3,0:3]    # broadcasted grid
```

---

### 58. How do you apply a function element-wise in NumPy?

```python
arr = np.array([1,2,3])
np.square(arr)             # built-in
np.vectorize(lambda x: x**2)(arr)  # custom
```

---

### 59. How do you profile NumPy performance?

Use `timeit`:

```python
import timeit
timeit.timeit('np.arange(1000)**2', setup='import numpy as np', number=1000)
```

Or `%timeit` in Jupyter.

---

### 60. What is memory-mapped file in NumPy (`np.memmap`)?

Used for huge arrays that donâ€™t fit in RAM.

```python
fp = np.memmap('data.dat', dtype='float32', mode='w+', shape=(1000,1000))
fp[0] = np.arange(1000)
fp.flush()
```

---

# NumPy Interview Questions (Expert: 61â€“100)

---

### 61. What are stride tricks in NumPy?

Allows viewing data in different shapes **without copying**.

```python
import numpy.lib.stride_tricks as st
arr = np.arange(10)
windowed = st.sliding_window_view(arr, 3)
print(windowed)
# [[0 1 2]
#  [1 2 3]
#  [2 3 4] ...]
```

---

### 62. Explain copy vs view in slicing.

```python
arr = np.arange(5)
s = arr[1:4]   # view
s[0] = 99
print(arr)     # [0 99 2 3 4]

c = arr[1:4].copy()  # deep copy
```

ðŸ‘‰ Slices are **views**, but `.copy()` makes new data.

---

### 63. How does NumPy handle broadcasting errors?

If shapes are **incompatible**, it raises `ValueError`.

```python
a = np.ones((3,2))
b = np.ones((3,))
a+b   # error
```

---

### 64. What is the difference between `nditer` and loops?

- `nditer` â†’ efficient iterator for arrays.

```python
arr = np.array([[1,2],[3,4]])
for x in np.nditer(arr):
    print(x)
```

ðŸ‘‰ Faster than Python loops.

---

### 65. How do you implement matrix rank in NumPy?

```python
A = np.array([[1,2,3],[4,5,6]])
np.linalg.matrix_rank(A)
```

---

### 66. How do you detect singular matrices?

```python
A = np.array([[1,2],[2,4]])
np.linalg.det(A)   # 0 â†’ singular
```

---

### 67. Explain difference between `.T` and `np.transpose()`.

- `.T` â†’ simple transpose (reverses dimensions).
- `np.transpose(arr, axes=...)` â†’ allows permuting axes.

```python
arr = np.arange(8).reshape(2,2,2)
arr.T.shape              # (2,2,2)
np.transpose(arr, (1,0,2)).shape
```

---

### 68. What is broadcasting in linear algebra context?

It enables operations like adding vector to matrix:

```python
A = np.array([[1,2],[3,4]])
b = np.array([10,20])
print(A+b)
```

---

### 69. Explain memory efficiency in NumPy.

- Uses **contiguous memory blocks** (C/Fortran order).
- Views avoid copies.
- Dtypes optimize memory usage.

---

### 70. Difference between C-order and F-order arrays.

- C-order â†’ row-major (default in NumPy).
- F-order â†’ column-major (Fortran style).

```python
arr = np.array([[1,2],[3,4]], order='F')
```

---

### 71. How do you improve performance with `numexpr`?

```python
import numexpr as ne
a = np.arange(10**6)
b = np.arange(10**6)
c = ne.evaluate("a*b + 2*a")
```

ðŸ‘‰ Faster than NumPy for large arrays due to parallelization.

---

### 72. How do you perform matrix decomposition (LU, QR)?

```python
from scipy.linalg import lu, qr
A = np.array([[1,2],[3,4]])
P,L,U = lu(A)   # LU decomposition
Q,R = qr(A)     # QR decomposition
```

ðŸ‘‰ SciPy extends NumPy for advanced decompositions.

---

### 73. How to compute Moore-Penrose pseudoinverse?

```python
A = np.array([[1,2],[3,4],[5,6]])
np.linalg.pinv(A)
```

---

### 74. What are masked arrays?

Used for missing/invalid data.

```python
import numpy.ma as ma
arr = ma.array([1,2,3], mask=[0,1,0])
print(arr)   # [1 -- 3]
```

---

### 75. How do you find memory usage of an array?

```python
arr = np.arange(1000)
print(arr.nbytes)   # total bytes
```

---

### 76. What are universal functions (ufuncs)?

- Vectorized functions operating element-wise.
- Examples: `np.add`, `np.sin`, `np.exp`.

```python
arr = np.array([1,2,3])
np.add(arr, 5)   # [6 7 8]
```

---

### 77. How do you create custom ufuncs?

```python
import numpy as np
def f(x): return x**2
ufunc = np.frompyfunc(f, 1, 1)
print(ufunc(np.array([1,2,3])))
```

---

### 78. How do you use `apply_along_axis`?

Applies function along axis.

```python
arr = np.arange(6).reshape(2,3)
np.apply_along_axis(np.sum, 1, arr)
```

---

### 79. What is the difference between `np.argwhere`, `np.where`, and `np.nonzero`?

- `where` â†’ condition results.
- `argwhere` â†’ indices where condition holds.
- `nonzero` â†’ indices of non-zero elements.

---

### 80. How to efficiently compute dot products for large arrays?

Use BLAS-optimized libraries (MKL/OpenBLAS).

```python
np.dot(a,b)   # internally uses BLAS
```

---

### 81. What is broadcasting pitfall with scalars and arrays?

Sometimes unexpected shapes cause errors.

```python
arr = np.arange(6).reshape(2,3)
arr + np.array([1,2])   # ValueError
```

---

### 82. How do you perform PCA using NumPy?

```python
X = np.random.randn(100,3)
X -= X.mean(axis=0)
cov = np.cov(X, rowvar=False)
eigvals, eigvecs = np.linalg.eig(cov)
```

---

### 83. How do you implement polynomial fitting?

```python
x = np.arange(10)
y = 2*x + 3
coeffs = np.polyfit(x,y,1)
```

---

### 84. How to generate a Toeplitz matrix?

```python
from scipy.linalg import toeplitz
toeplitz([1,2,3])
```

---

### 85. Explain memory alignment in NumPy.

- Arrays are aligned to word boundaries (8/16 bytes).
- Helps CPU vectorization.

---

### 86. How do you parallelize NumPy operations?

- Use `numexpr`, `dask`, or `joblib`.
- NumPy itself relies on BLAS multithreading.

---

### 87. What is the difference between `axis=0` and `axis=1`?

- `axis=0` â†’ operate across rows (down columns).
- `axis=1` â†’ operate across columns (across rows).

```python
arr = np.array([[1,2],[3,4]])
print(arr.sum(axis=0))   # [4 6]
print(arr.sum(axis=1))   # [3 7]
```

---

### 88. How do you tile vs broadcast arrays?

- `tile` â†’ explicitly repeats.
- Broadcasting â†’ implicit repeat (no memory cost).

---

### 89. How do you perform element-wise comparison of floats?

Use `np.isclose` or `np.allclose`.

---

### 90. What is the difference between `.copy(order='C')` and `.copy(order='F')`?

- `'C'` â†’ row-major copy.
- `'F'` â†’ column-major copy.

---

### 91. How do you compute FFT in NumPy?

```python
arr = np.array([1,2,3,4])
np.fft.fft(arr)
```

---

### 92. How do you compute convolution?

```python
np.convolve([1,2,3],[0,1,0.5])
```

---

### 93. How do you implement rolling average in NumPy?

```python
arr = np.arange(10)
window = 3
cumsum = np.cumsum(np.insert(arr,0,0))
rolling = (cumsum[window:] - cumsum[:-window]) / window
```

---

### 94. How do you reshape without copying?

```python
arr = np.arange(6)
arr2 = arr.reshape(2,3)  # view (if possible)
```

---

### 95. What is broadcasting in machine learning context?

It allows aligning data for vectorized operations, e.g. subtracting mean vector
from dataset.

---

### 96. How do you check array contiguity?

```python
arr.flags
```

- `C_CONTIGUOUS` or `F_CONTIGUOUS` flags.

---

### 97. How do you load very large CSV files efficiently?

Use `np.genfromtxt` or memory-mapped techniques. But often â†’ switch to
**Pandas**.

---

### 98. How do you use `np.select` for conditional logic?

```python
arr = np.array([10,20,30])
conds = [arr<15, arr<25]
choices = ['small','medium']
print(np.select(conds, choices, default='large'))
```

---

### 99. What is the difference between `np.argmax` and `np.max`?

- `argmax` â†’ index of max.
- `max` â†’ value of max.

---

### 100. What are common NumPy pitfalls in interviews?

- Confusing `axis=0` vs `axis=1`.
- Forgetting broadcasting rules.
- Using loops instead of vectorization.
- Confusing views vs copies.
- Expecting `flatten()` to return a view.

---
