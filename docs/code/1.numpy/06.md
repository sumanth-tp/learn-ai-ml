---

title: NumPy Exercises Solutions
sidebar_label: NumPy Exercises Solutions
sidebar_position: 16
--------------------

## Introduction

This lecture provides a **comprehensive walkthrough of common NumPy exercises**, covering the creation, manipulation, slicing, and aggregation of arrays.
These exercises reinforce your understanding of key NumPy concepts such as `arange`, `reshape`, `linspace`, and random number generation ‚Äî the foundational tools for **scientific computing and data manipulation** in Python.

Before beginning, import the NumPy library:

```python
import numpy as np
```

---

## 1. Creating Arrays of Zeros, Ones, and Fives

NumPy provides efficient ways to initialize arrays filled with zeros, ones, or
any constant value.

```python
zeros_array = np.zeros(10)
ones_array = np.ones(10)
fives_array = np.ones(10) * 5
```

**Explanation:**

- `np.zeros(n)` ‚Üí Creates an array of zeros of length `n`.
- `np.ones(n)` ‚Üí Creates an array of ones of length `n`.
- Multiplying `np.ones(10)` by `5` converts every element to `5`.

**Output Example:**

```
array([5., 5., 5., 5., 5., 5., 5., 5., 5., 5.])
```

---

### üîç Keyword: `np.zeros()` and `np.ones()`

These functions are widely used for **array initialization**, especially in deep
learning and scientific computation where placeholders for numerical data are
required.

---

## 2. Creating an Array of Integers from 10 to 50

```python
integers_10_to_50 = np.arange(10, 51)
```

**Explanation:**

- `np.arange(start, stop)` ‚Üí Generates integers from `start` to `stop - 1`.
- Here, `np.arange(10, 51)` includes 10 through 50.

---

## 3. Creating an Array of Even Integers from 10 to 50

```python
even_integers = np.arange(10, 51, 2)
```

**Explanation:**

- The third argument (`2`) is the **step size**, defining the increment.
- Output: `[10, 12, 14, ..., 48, 50]`.

---

### ‚öôÔ∏è Keyword: `np.arange()`

This is NumPy‚Äôs version of Python‚Äôs built-in `range()`, but it **returns an
array**, not a list ‚Äî enabling vectorized operations.

---

## 4. Creating a 3√ó3 Matrix with Values from 0 to 8

```python
matrix_3x3 = np.arange(9).reshape(3, 3)
```

**Explanation:**

- `np.arange(9)` ‚Üí Creates an array `[0, 1, 2, 3, 4, 5, 6, 7, 8]`.
- `.reshape(3, 3)` ‚Üí Converts the 1D array into a 3√ó3 matrix.

**Output:**

```
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
```

---

### üîç Keyword: `.reshape()`

Used to **change the dimensions** of an array without altering its data.

- The total number of elements must remain constant.

---

## 5. Creating a 3√ó3 Identity Matrix

```python
identity_matrix = np.eye(3)
```

**Explanation:** `np.eye(n)` creates an _n √ó n_ identity matrix (diagonal = 1,
others = 0). Identity matrices are fundamental in **linear algebra** (they
behave like ‚Äú1‚Äù in matrix multiplication).

**Output:**

```
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])
```

---

## 6. Generating Random Numbers

### Random Number Between 0 and 1

```python
random_number = np.random.rand(1)
```

### Array of 25 Random Samples from a Standard Normal Distribution

```python
random_samples = np.random.randn(25)
```

**Difference:**

- `rand()` ‚Üí Uniform distribution (0 to 1).
- `randn()` ‚Üí Standard normal (Gaussian) distribution centered around 0.

---

### ‚öôÔ∏è Keyword: Random Sampling

NumPy‚Äôs `random` module is crucial in **statistical simulations**, **ML model
initialization**, and **data augmentation**.

---

## 7. Creating a 10√ó10 Matrix with Values from 0.01 to 1.00

### Method 1 ‚Äì Using `arange`

```python
matrix_10x10 = np.arange(1, 101).reshape(10, 10) / 100
```

### Method 2 ‚Äì Using `linspace`

```python
matrix_10x10_alt = np.linspace(0.01, 1, 100).reshape(10, 10)
```

**Explanation:**

- `np.arange(1, 101)` ‚Üí Creates numbers from 1‚Äì100.
- Division by 100 scales values to 0.01‚Äì1.
- `np.linspace(start, stop, num)` ‚Üí Creates evenly spaced numbers.

---

### üîç Keyword: `np.linspace()`

Unlike `arange`, which depends on **step size**, `linspace` depends on the
**number of elements** desired. Useful when you need precise divisions (e.g.,
plotting).

---

## 8. Creating an Array of 20 Linearly Spaced Points Between 0 and 1

```python
linear_points = np.linspace(0, 1, 20)
```

**Output:**

```
array([0. , 0.0526, 0.1053, ..., 0.9473, 1.])
```

---

## 9. Array Slicing Examples

Assume a matrix `mat` has already been defined (e.g.,
`mat = np.arange(1, 26).reshape(5, 5)`).

### Select rows 12 onward and columns 1 onward

```python
subset_rows_cols = mat[1:, 1:]
```

### Select a single element (row 3, column 6)

```python
single_element = mat[3, 4]  # Adjust depending on shape
```

### Select first 3 rows, second column (as 2D array)

```python
column_slice_2d = mat[:3, 1:2]
```

---

### üîç Concept: Slicing Syntax

General format ‚Üí `array[start:stop, start:stop]`

- First part = rows
- Second part = columns
- Omit indices to include all (e.g., `:` means ‚Äúentire dimension‚Äù)

---

## 10. Selecting the Last Row and Last Two Rows

```python
last_row = mat[-1, :]        # Last row
last_two_rows = mat[-2:, :]  # Last two rows
```

**Explanation:**

- `:` ‚Üí All columns
- Negative indexing (`-1`) ‚Üí Access elements from the end

---

## 11. Summation and Standard Deviation

### Total Sum of All Elements

```python
total_sum = np.sum(mat)
```

### Standard Deviation

```python
std_dev = np.std(mat)
```

### Column-wise Summation

```python
column_sums = mat.sum(axis=0)
```

---

### ‚öôÔ∏è Keyword: `axis` Parameter

- `axis=0` ‚Üí Operates **vertically** (down columns).
- `axis=1` ‚Üí Operates **horizontally** (across rows).

---

## Advanced Example

Create a random 5√ó5 matrix and perform analysis:

```python
matrix = np.random.randint(1, 100, (5, 5))
print("Matrix:\n", matrix)
print("Sum of all elements:", matrix.sum())
print("Mean of columns:", matrix.mean(axis=0))
print("Max element:", matrix.max())
print("Standard deviation:", matrix.std())
```

This showcases combined **creation**, **aggregation**, and **statistical
computation** on arrays.

---

## Summary

- Created arrays (`zeros`, `ones`, `arange`, `linspace`, `eye`) and reshaped
  them.
- Used random sampling (`rand`, `randn`) for stochastic data.
- Practiced slicing and indexing for 1D and 2D arrays.
- Calculated **sum**, **standard deviation**, and **column-wise aggregates**.
- Learned about **axis control**, **broadcasting**, and **view vs copy**
  concepts.

---

## Practice Questions

1. Create an array of 50 fives.
2. Generate even numbers between 20 and 60.
3. Create a 5√ó5 matrix with numbers 1‚Äì25.
4. Select the element in row 4, column 3 of a 5√ó5 matrix.
5. Create a 4√ó4 identity matrix.
6. Generate a 1D array of 10 random integers between 0 and 100.
7. Create a 10√ó10 matrix of numbers between 0.01 and 1.00 using `linspace`.
8. Compute the mean, variance, and standard deviation of an array.
9. Extract the last two columns of a 5√ó5 matrix.
10. Demonstrate the difference between `np.sum()` and `np.mean()`.

---

## Answers

1. `np.ones(50) * 5`
2. `np.arange(20, 61, 2)`
3. `np.arange(1, 26).reshape(5, 5)`
4. `matrix[3, 2]`
5. `np.eye(4)`
6. `np.random.randint(0, 101, 10)`
7. `np.linspace(0.01, 1, 100).reshape(10, 10)`
8. ```python
   arr = np.arange(10)
   arr.mean(), arr.var(), arr.std()
   ```
9. `matrix[:, -2:]`
10. `np.sum()` adds all elements; `np.mean()` divides the sum by the count
    (average).
